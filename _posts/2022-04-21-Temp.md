---
layout: post
title: Try
category: uc
mathjax: true
---

{% include mathjax.html %}

ASCII
https://pages.cs.wisc.edu/~markm/ascii.html

**1)** 
$$ a + b = c $$

**2)** 

$$\\

a+b = c

\\$$

**3)**

$$\\

\begin{align}

a+b = c

\end{align}

\\$$

**4)**
$$\begin{align}

\\&a+b = c&\\

\end{align}$$


You're absolutely right to question this! At first glance, it seems both notations work fine for cyclic shifts. However, the key difference lies in **how polynomial multiplication and division align with encoding/decoding operations** in cyclic codes. Let me clarify why the standard notation $(c_0, c_1, \dots, c_{n-1})$ is preferred and where the reverse notation $(c_{n-1}, \dots, c_0)$ causes problems.

---

### **1. Both Notations Work for Cyclic Shifts (Your Example)**
You correctly showed that cyclic shifts work in both notations:
- **Standard notation**: $c = (1, 0, 1) \leftrightarrow 1 + x^2$ ? Shifted: $x \cdot (1 + x^2) = x + x^3 \equiv x + 1 \leftrightarrow (1, 1, 0)$.
- **Reverse notation**: $c = (1, 0, 1) \leftrightarrow x^2 + 1$ ? Shifted: $x \cdot (x^2 + 1) = x + x^3 \equiv x + 1 \leftrightarrow (1, 1, 0)$.

? **Both notations preserve cyclic shifts under multiplication by $x$.**

---

### **2. Where the Reverse Notation Breaks: Polynomial Multiplication/Division**
The critical issue arises when:
- **Encoding messages** (multiplying by $g(x)$), or
- **Decoding syndromes** (dividing by $g(x)$).

#### **Problem 1: Encoding (Polynomial Multiplication)**
In cyclic codes, encoding involves multiplying a message polynomial $m(x)$ by the generator polynomial $g(x)$:
$
c(x) = m(x) \cdot g(x).
$
- **Standard notation**: If $m = (m_0, m_1, \dots, m_{k-1})$ and $g = (g_0, g_1, \dots, g_{n-k})$, the multiplication aligns with polynomial arithmetic.  
  Example:  
  - $m(x) = m_0 + m_1 x$ (message),  
  - $g(x) = g_0 + g_1 x + g_2 x^2$ (generator),  
  - $c(x) = m(x) \cdot g(x)$ directly gives the codeword.

- **Reverse notation**:  
  - $m(x) = m_{k-1} x^{k-1} + \dots + m_0$ (backwards),  
  - $g(x) = g_{n-k} x^{n-k} + \dots + g_0$ (backwards),  
  - Now $m(x) \cdot g(x)$ does **not** directly correspond to the codeword. You'd need to reverse coefficients before/after multiplication.

#### **Example: Encoding in Reverse Notation Fails**
Let $g(x) = x^2 + x + 1$ (reverse of standard $1 + x + x^2$), and $m(x) = x + 1$ (message).  
- Compute $c(x) = m(x) \cdot g(x) = (x + 1)(x^2 + x + 1) = x^3 + 2x^2 + 2x + 1$.  
- Reduce mod $x^3 - 1$ and coefficients mod 2: $c(x) = 1$.  
- This gives $c = (1, 0, 0)$, which is **not a valid cyclic codeword** for this $g(x)$.  

In standard notation, the same operation would yield $c(x) = (1 + x)(1 + x + x^2) = 1 + 2x + 2x^2 + x^3 \equiv 1 + x^3 \equiv 1 + 1 = 0$ (invalid due to trivial case, but the process is correct).

---

### **Problem 2: Syndrome Calculation (Polynomial Division)**
Decoding involves dividing the received polynomial $r(x)$ by $g(x)$ to compute syndromes.  
- **Standard notation**: Polynomial long division works naturally (starting from low-degree terms).  
- **Reverse notation**: You'd need to reverse $r(x)$ and $g(x)$ before dividing, then reverse the result.  

#### **Example: Division Fails in Reverse Notation**
Let $r(x) = x^2 + 1$ (received), $g(x) = x^2 + x + 1$ (generator).  
- Standard notation: Divide $1 + x^2$ by $1 + x + x^2$.  
  - This works as expected in coding theory.  
- Reverse notation: Divide $x^2 + 1$ by $x^2 + x + 1$.  
  - The quotient is $1$, remainder $-x$ (doesn't match standard syndrome calculations).  

---

### **3. Why Standard Notation is Universally Adopted**
1. **Natural alignment with shift registers**:  
   - Linear feedback shift registers (LFSRs) used in hardware process bits from $c_0$ to $c_{n-1}$.  
   - Reverse notation would require reversing bits before/after operations.  

2. **Consistency with polynomial arithmetic**:  
   - Mathematical literature defines polynomials as $c_0 + c_1 x + \dots$.  
   - Reversing coefficients breaks compatibility with algebra textbooks.  

3. **Avoiding reordering in computations**:  
   - In standard notation, you can directly compute $m(x) \cdot g(x)$ or $r(x) \mod g(x)$ without flipping coefficients.  

---

### **Key Insight**
- **Cyclic shifts work in both notations** (as you showed).  
- **But encoding/decoding breaks in the reverse notation** because polynomial operations no longer align with codeword representations.  

### **When Reverse Notation is Acceptable**
- If you're **only performing shifts** (no multiplication/division), it works.  
- In **finite field tables** (like $\mathbb{F}_8$), where no polynomial operations are performed.  

### **Conclusion**
The standard notation $(c_0, c_1, \dots)$ is preferred because:  
1. It preserves polynomial arithmetic for encoding/decoding.  
2. It aligns with hardware implementations.  
3. It's consistent with mathematical conventions.  

The reverse notation $(c_{n-1}, \dots, c_0)$ works for shifts but **fails for polynomial multiplication/division**, which are fundamental to cyclic codes.  

Would you like a side-by-side comparison of encoding in both notations to see the difference concretely?

<div class="cboxed">
 


Visitor Count &nbsp;&nbsp;<a href="https://www.hitwebcounter.com" target="_blank">
<img src="https://hitwebcounter.com/counter/counter.php?page=20155159&style=0002&nbdigits=6&type=ip&initCount=12000" title="Counter Widget" Alt="Visit counter For Websites"   border="0" /></a>
 
 
</div>

<div style="clear:both"></div>

<br>

---
layout: post
mathjax: true
title: Few questions answered about PLONK
---

{% include mathjax.html %}

---- 

#### Copy Constraints
**Q:** Why are Copy Constraints required in PLONK unlike the older SNARKs?

**A:** Older SNARKs like [Groth16](/R1CSQAP/), Pinocchio etc only verify the computation in each of the gates but do not have something like Copy Constraints which verify the consistency across the gates. This is because the older SNARKs use a Witness/Solution vector in verifying computation in each of the gates. This Solution vector is common across all the gates. This automatically ensures the consistency across the gates which is what the Copy Constraints in PLONK is used to verify. 

--- 

#### Cosets
**Q:** In Section 8.1 (page 26), 2 cosets of the multiplicative subgroup $H$ are created. Why are these required & how are they used?

**A:** PLONK uses a permuation check to enforce the copy constraints. The circuit has $n$ gates. Each gate has a left & right input and an output. So there are a total of $3n$ elements. The copy constraints check conditions like these 

- The output of the first gate is the left input of the second gate   
- The same public input is the left input of both the 19th and the 22nd gate

So the condition which needs to be checked may involve any 2 or more of the $3n$ elements. Hence we need $3n$ distinct index numbers for representing the $3n$ elements. However, we have a set (subgroup) of only $n$ elements. So we construct 2 cosets from the group. Since cosets are always disjoint, we end up with a total of $3n$ distinct elements across $H$ & the 2 cosets.

Note that these $3n$ elements are used as the $y$-coordinate while doing Lagrange Interpolation. Only the elements of $H$ are used as the $x$-coordinate both here & also while interpolating the gate constraints. The $x$-coordinate represents the gate numbers & hence the $n$ elements of $H$ are enough to represent it

---  
#### Blinding
**Q:** In Round 1 (Page 28 of the PLONK paper), random blinding scalars are used to modify the 3 wire polynomials (the polynomials representing the left, right & output of the gates). What exactly is blinding?

**A:** Let's say you have a polynomial $f(X)$ of degree $d$ & it's commitment $C_f$. Let's say the verifier selects random value $r$ & the prover sends the evaluation of $f$ at $r$ i.e. $f(r) = z$

A polynomial of degree $d$ can be recreated with $d+1$ evaluations by using Lagrange Interpolation. So, each opening of a Polynomial Commitment leaks some info about the polynomial. 

Hence SNARKs use a trick called blinding to make it zero knowledge. Multiply the vanishing polynomial $z_H$ by a random Polynomial $R(X)$ & add it to $f(X)$ to create a new polynomial $F(X)$

$F(X) = RX)\cdot z_H + f(X)$

Instead of committing and opening $f(X)$, the prover commits & opens $F(X)$. 

$z_H$ is zero on the set the constraints are checked on - so on this set $F(X) = f(X)$. So other than in the commitment & opening, the SNARK can continue to use $f$ instead of $F$

The next question is what should be the degree of the random polynomial $R$. That depends on how many points you open $f$ at - if there is an opening at only one point, then $R$ needs to be of minimum degree $1$, if there are two openings, then there $R$ needs to be at least of degree $2$. The new polynomial $F(X)$ which is going to be opened instead of $f(X)$ has to be of degree of $f$ plus the number of points at which $f$ needs to be opened.

In Round 1, the left, right & output polynomials are evaluated only at one point each & hence a random polynomial of degree $1$ is used for blinding - for e.g. for blinding the opening of $a(X)$, $R(X) = (b_1 X + b_2)$ is used as the random polynomial. The round 2 polynomial $z(X)$ is evaluated at 2 points & hence a degree 2 random polynomial $(b_7 X + b_8 X + b_9)$ is used.  

---- 
#### Linear Independence
**Q:** In Round 3 (Page 29), when combining different polynomials to form $t(X)$, why are different powers of $\alpha$ i.e. $ \alpha^0, \alpha^1, \alpha^2$ used.

**A:** Let's say we have 4 polynomials - $f_1$, $f_2$, $f_3$ & $f_4 \in \mathbb F_p[X]$ where the max degree of these polynomials is $d$ which is very, very small as compared to $p$.

We want to combine them into one polynomial $f$ such that if $f$ is 0 at some point, then all of $f_i$'s are also zero at the same point.

Consider the set ${1, z, z^2, z^3}$
This is a linearly independent set.

We can use this set to combine four variables $a_1, a_2, a_3$ & $a_4$ like this

$g(Z) = a1 + a2\cdot Z + a3\cdot Z^2 + a4\cdot Z^3$  

If $g(Z)=0$ at some $Z \ne 0$, then it means $a_1 = a_2 = a_3 = a_4 = 0$ (by the definition of a linearly independent set)

So, we can combine the polynomials $f_i$'s as

$f(X,Z) = f1(Z) + Z\cdot f2(x) + Z^2 \cdot f3(X) + Z^3\cdot f4(X)$

At some  $X = r_1$, let 

$f_1(r_1) = a_1$, $f_2(r_1) = a_2$, $f_3(r_1) = a_3$, $f_4(r_1) = a_4$,

So now

$f(X=r_1, X) = a1 + a2\cdot Z + a3\cdot Z^2 + a4\cdot Z^3$

At some random value $r_2$ chosen from $\mathbb F_p$, if 

$f(X=r_1, Z = r_2) = 0$   

then it means  $a1 = a2 = a3 = a4 = 0$ 

i.e. $f_1(r_1, r_2) =f_2(r_1, r_2) = f_3(r_1, r_2) =  f_4(r_1, r_2) = 0$

If $f_1$, $f_2$, $f_3$, $f_4$ are all $0$ at some random value $r_2$, then by the Schwartz-Zippel lemma, $f_1$, $f_2$, $f_3$, $f_4$ are all zero polynomials with very high probability because the maximum degree of these polynomials is very, very small as compared to $p$

So if we want to test if multiple polynomials are zero polynomials or not, we combine them using a lineraly independent set so we can test them with just one evaluation at a random point rather than testing them separately. Round 3 in the PLONK paper creates the polynomial $t(X)$ with the linearly independent set $[1, \alpha, \alpha^2]$ to do this. In Round 5, the set $\lbrace 1, v, v^2, v^3, v^4, v^5 \rbrace$ is used to combine several polynomials to form a single opening proof polynomial $W_\zeta(X)$. It may be used at other places also.

---- 
#### Multiplicative Subgroup
**Q:** Why does PLONK use a multiplicative subgroup?

**A:** There are multiple reasons why PLONK uses a multiplicative subgroup

$(1)\space$ [Every element of a finite field is a root of unity](/WeilMOV#roots-of-unity). A Finite Field $\mathbb F_p$ has a multiplicative subgroup of order $n$ only if $n$ divides $p-1$. All primitive roots of unity in a finite field also form a multiplicative subgroup of the field. Let $\omega$ be a primitive $n$th root of unity in $\mathbb F_p$ i.e. $\omega^n = 1$ This forms a multiplicative subgroup of order $n$ - let's call it $H$

$H = \lbrace 1, \omega, \omega^2, \omega^3, ..., \omega^{n-1} \rbrace$ 
    
In [Groth16](/R1CSQAP/) with $n$ gates, we compute the vanishing polynomial 

$z_H(X) = (X-1)\cdot (X-2)\cdot(X-3) \dots \dots(X-n)$ (where 1, 2, 3 etc are the gate numbers)

The number of gates is usually very large (may be a million gates or more). So, computing the vanishing polynomial which has a million such terms is quite expensive.

PLONK numbers the gates using the elements of the multiplicative subgroup $H$. Now the vanishing polynomial becomes  

$z_H(X) = (X-1) \cdot(X-\omega)\cdot (X-\omega^2)\cdot ...\cdot (X-\omega^{n-1})$

Now,

Let's consider the polynomial $X^n - 1$

- For $X = 1$,

  $1^n = 1$, so $(X-1)$ is a root of $X^n - 1$

- For $X = \omega$, 

    Since $\omega$ is the $n$th root of unity, $X^n = 1$ & hence $\omega$ is a root of $X^n - 1$

- For $X = \omega^2$ 

  ${\omega^2}^n = {\omega^n}^2 = {1}^2 = 1$.

  So $\omega^2$ is also a root of $X^n - 1$

- Like this, we can prove that every element of $H$ is a root of $X^n - 1$ & since $X^n - 1$ is degree $n$, the maximum number of roots it can have is $n$.
  
So $X^n - 1 = (X-1) \cdot (X-\omega)\cdot (X-\omega^2) \dots \dots  (X-\omega^{n-1})$

  So $z_H = X^n - 1$

  So now the vanishing polynomial $Z_H$ is very easy to compute instead of having to multiply a million terms.


$(2)$ Using a multiplicative subgroup allows an efficient & elegant Product Check on the subgroup.

With a polynomial $m(X)$, the prover has to prove that 

$\prod_{X\in H} m(X)  = 1$


i.e. the Prover has to prove that


$m(1)\cdot m(\omega) \cdot m(\omega^2) \dots \dots m(\omega^{n-1}) = 1$

Let's define another polynomial $z(X)$ such that  

- $z(1) = 1$

- $z(X\omega) = z(X) \cdot m(X)$

Considering the above definition of $z$,

**For** $X=1$,

  $z(1\cdot \omega) = z(1)\cdot m(1)$

  i.e. $z(\omega) = m(1)$


**For** $X=\omega$, 
  
  $z(\omega^2) = z(\omega\cdot\omega) = z(\omega)\cdot m(\omega) = m(1) \cdot m(\omega)$
  
  i.e. $z(\omega^2) = m(1)\cdot m(\omega)$

**For** $X=\omega^2$, 
  
  $z(\omega^3) = z(\omega^2\cdot\omega) = z(\omega^2)\cdot m(\omega^2) = m(1) \cdot m(\omega)\cdot m(\omega^2)$

  i.e. $z(\omega^3) = m(1) \cdot m(\omega)\cdot m(\omega^2)$

Likewise,

  $z(\omega^4) = m(1)\cdot m(\omega)\cdot m(\omega^2)\cdot m(\omega^3)$

$\cdots$

$\cdots$

With $X = \omega^{n-1}$, 

  $z(\omega^n) = m(1)\cdot m(\omega)\cdot m(\omega^2)\dots \dots m(\omega^{n-1})$

But since $\omega^n = 1$ (because $\omega$ is the $n$th root of unity)

  $z(1) = m(1)\cdot m(\omega)\cdot m(\omega^2) \dots \dots m(\omega^{n-1})$


So to prove $\prod_{X\in H} m(X)  = 1$, the prover has to prove 

$1)$  $z(1) = 1$

and that 

$2)$  $z(1)$ was built accumulatively from the earlier $z$'s

which can be done elegantly & efficiently as described in that section of the PLONK paper.

This proof is based on our definition of $z(X)$

$z(X\omega) = z(X) \cdot m(X)$

We can define $z$ so because we are operating in a multiplicative subgroup 
$H = \lbrace 1,\omega, \omega^2, \omega^3, ..., \omega^{n-1} \rbrace$, where multiplying by each element  $\omega$ gives us the next element & thus we get the "right shift" relation between $z$ at an element & $z$ at the next element.

Section $5$ of the PLONK Paper describes "Polynomial protocols for identifying permutations" which uses the above product check to prove that $\prod_{X\in H} \frac{f'(X)}{g'(X)}  = 1$ with $m(X)$ defined as $m(X) = \frac{f'(X)}{g'(X)}$ 

$(3)$ Using a multiplicative subgroup of a Finite Field is required for usage of [Fast Fourier Transform](https://vitalik.ca/general/2019/05/12/fft.html) to speed up some operations.


[![Hits](https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Frisencrypto.github.io%2FPLONKWHY%2F&count_bg=%2379C83D&title_bg=%23555555&icon=&icon_color=%23E7E7E7&title=hits&edge_flat=false)](https://hits.seeyoufarm.com)
